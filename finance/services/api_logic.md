ЛОГИКА РАБОТЫ С PrivatBank API (коротко и однозначно)
==================================

Принцип работы АПИ
----------------------
На форме банков есть кнопка "Синхронизация"
В зависимости от МФО банка вызывается соответствующий клиент 
(логика выбора клиента реализована в bank_dispatcher.py и ее нужно оптимизировать, как по мне там оч ложный код)
Дальше пойдем оптимизировать логику для НБУ






Цель: надёжно получать список счетов, остатки и транзакции через Autoklient API (https://acp.privatbank.ua).

1) Общий workflow
------------------
1. GET /statements/settings — health check
   - Проверяем: `status == "SUCCESS"`, `settings.phase == "WRK"`, `settings.work_balance == "N"`.
   - Запоминаем `settings.stdate` (последняя надёжная итоговая дата) — использовать как верхнюю границу для запросов балансов/выписок.

2. GET /statements/balance?startDate={DATE} — список счетов + остатки
   - `DATE` обычно: `stdate` или вчера (формат `DD-MM-YYYY`).
   - Ответ: массив объектов (каждый — счёт/IBAN и `balanceOut`).
   - Для каждого объекта: **проверить наличие `iban` и `currency`**. Если не хватает — пропустить и залогировать причину.

3. Для каждого счёта: GET /statements/transactions?startDate={START}&endDate={END}&acc={IBAN}&limit={N}
   - Обрабатывать страницы: если `exist_next_page==true` — взять `next_page_id` и затем использовать `followId=next_page_id`.
   - Дедупликация: **в первую очередь `TECHNICAL_TRANSACTION_ID`**, fallback: `REF-REFN` или `id/uniqueId`.
   - Нормализовать данные: знак суммы по `TRANTYPE`, парсинг дат (поддержать `DD.MM.YYYY`, `YYYY-MM-DD` и т. п.), `balance_after`, `raw_data`.

4. (Опционально) GET /api/proxy/currency/history?startDate={START}&endDate={END}
   - Ограничение: период ≤ 15 дней → при необходимости разбивать на отрезки.
   - Использовать `nbuRate` или `rate` в зависимости от задачи.

---

Важные HTTP/технические нюансы
--------------------------------
- Заголовки: **`User-Agent`**, **`token`**, и при необходимости **`id` (Client ID / CID)** — всегда отправлять.
- Кодировка: сервер может возвращать cp1251. При парсинге **сначала** пытаться `response.json()`, при ошибке делать `json.loads(response.content.decode('cp1251', errors='replace'))`.
- Параметры: поддерживать `limit` в запросах транзакций (рекомендуемо 100).
- Politeness: не спамить API — добавить конфигурируемую задержку между запросами (между страницами и между счетами) — например 0.3–1s.

Логи и диагностика
-------------------
- При HTTP 4xx/5xx логировать код, URL, первые N байт тела (truncate, например 1000 chars) и request id/headers (без токена в логах).
- При пропуске счёта/транзакции логировать причину и небольшой фрагмент данных.

Требования к интеграции в Odoo (реализация)
------------------------------------------
- Метод `check_api_status()` должен возвращать True/False и, по возможности, `settings` (чтобы можно было взять `stdate`).
- `fetch_balances_for_all_accounts(startDate, endDate)` должен принимать дату/диапазон и возвращать список балансов.
- `fetch_transactions_page(startDate, acc=None, followId=None, limit=100)` — поддерживать `limit` и `followId`.
- `import_accounts(bank, startDate=None, endDate=None)` — использовать баланс как источник для создания/обновления `dino.bank.account`.
- `import_transactions(bank, account)` — (УВЕДОМЛЕНИЕ) функциональность импорта транзакций отключена в текущей версии. Поддерживается только импорт балансов.

Приоритетный список изменений (предлагаю выполнить в этом порядке)
-----------------------------------------------------------------
A. Срочно (высокий приоритет)
  1) Использовать `settings.stdate` из `/settings` как верхнюю безопасную дату для балансов/выписок.
  2) Улучшить обработку кодировки (жёсткий rollback: `resp.content.decode('cp1251', errors='replace')`).
  3) Добавить unit‑tests для `import_accounts` и `import_transactions` (создание/обновление/skipped, пагинация, дедупликация).

B. Средний приоритет
  4) Добавить configurable delay между запросами (throttling).
  5) Поддержать параметр `limit` в `fetch_transactions_page` и использовать разумное значение (например 100).
  6) Улучшить логирование: при ошибках включать snippet ответа, URL и request id.

C. Низкий / опционально
  7) Реализовать импорт курсов через `/api/proxy/currency/history` (с учётом 15‑дневного лимита).
  8) Добавить интеграционные тесты и документацию примеров (curl/Postman) для типовых сценариев.

Примеры быстрых проверок (curl)
-------------------------------
```
DATE=25-12-2025
curl -s -H "User-Agent: DinoERP Integration" -H "token: $TOKEN" -H "id: $CID" \
  "https://acp.privatbank.ua/api/statements/balance?startDate=$DATE&endDate=$DATE" | jq .
```

Пример запуска в контексте Odoo (проверка и import_accounts):
```python
# scripts/check_privat_accounts.py (run in project with parse_config)
from odoo import api, odoo
odoo.tools.config.parse_config(['-d','dino24_dev','--addons-path=addons,../odoo_projects/dino24_addons'])
with api.Environment.manage():
    env = api.Environment(cr=None, uid=1, context={})
    bank = env['dino.bank'].search([('mfo','=','305299')], limit=1)
    from finance.services import privat_service
    print(privat_service.import_accounts(bank, startDate='25-12-2025'))
```

Замечание по безопасности
-------------------------
- Никогда не логируйте полный токен. В логах храните только метаданные и обрезанные фрагменты ответов.

---

Если подтверждаете — могу начать реализацию по приоритету A (внести правки в клиент и сервис и добавить тесты) и подготовить PR с описанием изменений.

---
Подробный алгоритм работы при нажатии кнопки "Синхронизация"
============================================================

Ниже описана пошаговая логика, которая должна выполняться при вызове `bank_dispatcher.dispatch_sync` для банка "ПриватБанк".

**Входные данные:** объект `dino.bank` с заполненными `api_key` и `api_client_id`.

### Шаг 1: Health Check — Проверка статуса API

1.  **Вызов:** `PrivatClient.get_api_settings()`
    *   **Запрос:** `GET /api/statements/settings`
    *   **Заголовки:** `token`, `id` (CID).
2.  **Анализ ответа:**
    *   Если HTTP-ошибка (4xx, 5xx) или ответ не JSON → **Прервать синхронизацию**, показать пользователю ошибку (например, "Неверный токен или API недоступен").
    *   Проверить JSON:
        *   `status` должен быть `"SUCCESS"`.
        *   `settings.phase` должен быть `"WRK"`.
        *   `settings.work_balance` должен быть `"N"`.
    *   Если любое из условий не выполнено → **Прервать синхронизацию**, показать уведомление (например, "Сервер ПриватБанка занят, попробуйте позже").
3.  **Сохранение даты:**
    *   Извлечь и сохранить дату `settings.stdate` (например, `'25-12-2025'`). Это последняя подтвержденная банком дата, до которой можно безопасно запрашивать данные.

### Шаг 2: Импорт и обновление счетов (Accounts)

1.  **Вызов:** `privat_service.import_accounts(bank, startDate=stdate)`
    *   **Запрос:** `GET /statements/balance?startDate={stdate}`
    *   **Логика:** Запросить балансы на последнюю подтвержденную дату `stdate`.
2.  **Обработка списка счетов:**
    *   Для каждого счета в полученном массиве `balances`:
        *   **Проверка:** Убедиться, что у счета есть поля `iban` и `currency`. Если нет → пропустить этот счет, записать `warning` в лог.
        *   **Поиск валюты:** Найти `res.currency` в Odoo по коду `currency`. Если не найдено → пропустить счет, записать `warning` в лог.
        *   **Поиск/создание `dino.bank.account`:**
            *   Искать существующий счет по `iban`.
            *   **Если найден:** Обновить его данные (название, баланс, `external_id`=`acc`).
            *   **Если не найден:** Создать новую запись `dino.bank.account`.
3.  **Результат:** В системе Odoo созданы или обновлены банковские счета, актуальные на дату `stdate`.

### Шаг 3: Импорт транзакций для каждого активного счета

1.  **Получение списка счетов:**
    *   Выбрать из базы все `dino.bank.account`, у которых `bank_id` соответствует текущему банку и `active = True`.
2.  **Цикл по счетам:** Для каждого `dino.bank.account` выполнить следующие действия.
3.  **Определение периода для запроса:**
    *   `startDate`:
        *   Если у счета заполнено поле `last_import_date`, `startDate` = `last_import_date` минус 1 день.
        *   Иначе, если у банка заполнено `start_sync_date`, `startDate` = `start_sync_date`.
        *   Иначе, `startDate` = сегодня минус 30 дней (fallback).
    *   `endDate`: всегда использовать `stdate` из Шага 1.
4.  **Пагинация транзакций (внутренний цикл):**
    *   **Первый вызов:** `PrivatClient.fetch_transactions_iter(startDate, endDate, acc=account.external_id, limit=100)`
    *   **Для каждой страницы (page) из ответа:**
        *   Обработать массив `page['transactions']`.
        *   **Для каждой транзакции (tx):**
            *   **Дедупликация:** Найти `dino.bank.transaction` по `external_id`. `external_id` формируется из `tx['TECHNICAL_TRANSACTION_ID']`. Если его нет, используется `REF-REFN`. Если запись найдена → обновить ее и перейти к следующей транзакции.
            *   **Маппинг полей:** Преобразовать данные транзакции `tx` в формат Odoo (сумма со знаком, дата, описание, данные контрагента, `raw_data`).
            *   **Создание:** Вызвать `dino.bank.transaction.create_from_api()`.
        *   **Проверка следующей страницы:** Если `page['exist_next_page'] == true`, взять `page['next_page_id']` и сделать следующий запрос с параметром `followId`. Между запросами сделать небольшую паузу (`time.sleep`).
5.  **Обновление даты последней синхронизации:**
    *   После успешного импорта всех транзакций для счета, обновить поле `dino.bank.account.last_import_date` на дату самой последней транзакции.

### Шаг 4: Завершение и уведомление

1.  Собрать статистику по всем операциям (сколько счетов создано/обновлено, сколько транзакций создано/обновлено).
2.  Показать пользователю итоговое уведомление.

Этот алгоритм обеспечивает последовательную и надежную синхронизацию, начиная с проверки доступности API и заканчивая итеративным получением данных.




Импорт транзакций

Для импорта транзакций за большой период важно учитывать ограничения API Привата по объему данных и стабильности соединения. Если вы попытаетесь выгрузить год одним запросом, вы либо получите таймаут, либо неполные данные.

Вот настройки и алгоритм для реализации надежного импорта «в долгую»:

1. Настройки параметров запроса
Для большого периода используйте метод пагинации.

Endpoint: GET https://acp.privatbank.ua/api/statements/transactions

limit: Установите 500 (максимально допустимое значение). Это уменьшит количество запросов к серверу.

startDate / endDate: Не делайте период более 31 дня за одну итерацию, если транзакций очень много. Оптимально — идти по месяцам.

followId: Ключевой параметр. Если в ответе exist_next_page: true, вы обязаны взять next_page_id и подставить его в следующий запрос.

2. Алгоритм импорта (Step-by-Step)
Дробление периода: Разбейте ваш большой период (например, год) на отрезки по 1 месяцу.

Цикл пагинации (внутри месяца):

Запрос 1: startDate=01-01-2025&endDate=31-01-2025&limit=500

Если получили next_page_id:

Запрос 2: startDate=01-01-2025&endDate=31-01-2025&limit=500&followId=ID_ИЗ_ПРЕДЫДУЩЕГО_ОТВЕТА

Обработка данных (СУБД):

Дедупликация: При импорте за большой период неизбежны наложения. Всегда проверяйте транзакцию по полю TECHNICAL_TRANSACTION_ID. Если такой ID уже есть в базе — пропускайте запись или обновляйте её.

Кодировка: Убедитесь, что обрабатываете ответ в cp1251, чтобы не «посыпались» кириллические назначения платежей.

3. Технические ограничения и паузы
Таймауты: Между страницами (followId) делайте небольшую паузу (0.5 – 1 сек), чтобы сервер Привата не оборвал соединение по Flood Control.

Время выполнения: Если импорт идет в Odoo, запускайте его через cron или background task, так как процесс за большой период может длиться несколько минут.

4. Настройки заголовков (Headers)
Для стабильности в Postman/коде:

HTTP

User-Agent: PostmanRuntime/7.26.8
Content-Type: application/json; charset=cp1251
id: YOUR_CLIENT_ID
token: YOUR_TOKEN
Accept-Encoding: gzip, deflate, br
(Использование gzip в заголовках существенно ускорит получение больших объемов JSON-данных).

Резюме:
Чтобы не «положить» интеграцию, идите по схеме: Месяц → Цикл по 500 записей через followId → Запись в базу с проверкой на дубли по Technical ID → Следующий месяц.